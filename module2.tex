\documentclass[11pt]{beamer}

      \usepackage{hyperref}

      \usepackage{color}

      \usepackage{amsmath}

      \usepackage{listings}
      \lstset{numbers=none,language=[ISO]C++,tabsize=4,
  frame=single,
  basicstyle=\small,
  showspaces=false,showstringspaces=false,
  showtabs=false,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{red},
  }

      \usepackage{verbatim}

\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{minted}
\providecommand{\alert}[1]{\textbf{#1}}

\title{module2}
\author{gar}
\date{}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs Org-mode version 7.9.3f}}

\begin{document}

\maketitle

\begin{frame}
\frametitle{Outline}
\setcounter{tocdepth}{3}
\tableofcontents
\end{frame}
\section{Branching and Looping}
\label{sec-1}
\begin{frame}[fragile]\frametitle{Branching}
\label{sec-1-1}

\begin{itemize}
\item When an algorithm makes a choice to do one of two or more things, it's called branching
\item Different options are available to make choices
\begin{itemize}
\item \verb~if~ : to conditionally execute the statements in its block (the statements written between \verb~{ ... }~ after the \verb~if~ keyword)
\item \verb~if-else~ : to make two-way decisions
\item Cascaded \verb~if-else~ : for multi-way decision
\item Nested \verb~if-else~ : branching within branching
\item \verb~Switch~ : making multi-way decisions in another way
\end{itemize}
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Two-way Selection: If}
\label{sec-1-2}

\begin{itemize}
\item Required to make decisions
\item E.g. To decide whether a person is senior citizen, we check the age

\begin{minted}[]{C}
if (age >= 60)
  printf("Person is a senior citizen");
\end{minted}
\item In the example, we are printing the statement only when the expression is true
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Two-way Selection: If}
\label{sec-1-3}

\begin{itemize}
\item Whenever we require more than one statement to be executed within the \verb~if~ block, we need the braces. Otherwise, we may leave out the braces

\begin{minted}[]{C}
if (age >= 60)
{
  printf("Person is a senior citizen");
  ticket_cost = 0.9*ticket_cost; /* Give a discount */
}
\end{minted}
\item If the braces were removed, everybody gets a discount and the ticket seller's profit would be reduced
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Two-way Selection: If-Else}
\label{sec-1-4}

\begin{itemize}
\item The if-else statement tells what to do when an expression is true and what to do when it's false
\item The syntax is

\begin{minted}[]{C}
if (expression)
  statement_1
else
  statement_2
\end{minted}
\item E.g. To print whether a number is even or odd

\begin{minted}[]{C}
if (num%2 == 0)
  printf("number is even");
else
  printf("number is odd");
\end{minted}
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Multi-way decision: Else-If (Cascaded if-else)}
\label{sec-1-5}

\begin{itemize}
\item The construction of a multiway decision is written as

\begin{minted}[]{C}
if (expression1)
  statement1
else if (expression2)
  statement2
else if (expression3)
  statement3
else
  statementn
\end{minted}
\item As soon as one of the expressions holds true, the statements inside the body is executed and goes out of the \verb~else-if~ chain
\item The \verb~else~ part serves as a default, when none of the given expressions is true
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Multi-way decision: Else-If}
\label{sec-1-6}

\begin{itemize}
\item E.g. To display the grade obtained by the student in an exam

\begin{minted}[]{C}
if (marks >= 90)
  printf("A");
else if (marks >= 80 && marks < 90)
  printf("B");
else if (marks >= 70 && marks < 80)
  printf("C");
else if (marks >= 60 && marks < 70)
  printf("D");
else if (marks >= 50 && marks < 60)
  printf("E");
else 
  printf("F");
\end{minted}
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Two-way Selection: Nested If-Else}
\label{sec-1-7}

\begin{itemize}
\item E.g. Displaying maximum of three numbers

\begin{minted}[]{C}
if (a > b) {
  if (a > c)
    max = a;
  else
    max = c;
}
else {
  if (b > c)
    max = b;
  else
    max = c;
}
\end{minted}
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Switch Statement}
\label{sec-1-8}

\begin{itemize}
\item This is another multi-way decision that tests whether an expression matches one of a number of constant integer values, and branches accordingly

\begin{minted}[]{C}
switch (expression) {
  case constant1: statements
                  break;
  case constant2: statements
                  break;
  default: statements
}
\end{minted}
\item If the expression is \verb~constant1~, the statements in front of that number is executed, and the \verb~break~ gets the execution flow out of the switch block
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Switch Statement -- Example 1}
\label{sec-1-9}

\begin{itemize}
\item A simple calculator: enter two numbers and an operator to perform the required arithmetic operation
\end{itemize}

\begin{minted}[]{C}
int a,b;
char op;
scanf("%d%d", &a, &b);
scanf("%c", &op);
switch (op)
{
  case '+': printf("%d\n", a+b);
            break;
  case '-': printf("%d\n", a-b);
            break;
  case '*': printf("%d\n", a*b);
            break;
  case '/': printf("%f\n", (float)a/b);
            break;
  default: printf("Enter an arithmetic operator\n");
}
\end{minted}
\end{frame}
\begin{frame}[fragile]\frametitle{Switch Statement -- Example 2}
\label{sec-1-10}

\begin{itemize}
\item Tell whether the entered character is a vowel or not
\end{itemize}

\begin{minted}[]{C}
char ch;
scanf("%c", &ch);
switch (ch)
{
  case 'a':
  case 'e':
  case 'i':
  case 'o':
  case 'u': printf("%c is a vowel\n"); break;
  default : printf("%c is not a vowel\n");
}
\end{minted}
\begin{itemize}
\item If upper case letters are required, that may be added with the corresponding \verb~case~ labels
\item If a statement is missing after a \verb~case~ constant, it will carry on the execution from the first statement it sees. In this example, if `a' is entered, it executes the first printf statement and breaks out of the switch block
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Switch Statement -- Example 3}
\label{sec-1-11}

\begin{itemize}
\item Rewriting the grading example using switch instead of else-if
\end{itemize}

\begin{minted}[]{C}
switch (marks / 10)
{
  case 9: printf("A\n"); break;
  case 8: printf("B\n"); break;
  case 7: printf("C\n"); break;
  case 6: printf("D\n"); break;
  case 5: printf("E\n"); break;
  default: printf("F\n");
}
\end{minted}
\end{frame}
\begin{frame}[fragile]\frametitle{Ternary Operator ?:}
\label{sec-1-12}

\begin{itemize}
\item ? : is called a ternary operator since it takes three expressions
\item Syntax is
  \emph{expr$_1$} ? \emph{expr$_2$} : \emph{expr$_3$}
\item If the expression \emph{expr$_1$} is true (non-zero), then \emph{expr$_2$} is evaluated. Otherwise, \emph{expr$_3$} is evaluated.
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Ternary Operator ?: -- Example}
\label{sec-1-13}

\begin{itemize}
\item To compute the max of two numbers, these two code samples are equivalent
\item Using if-else

\begin{minted}[]{C}
if (a>b)
  max = a;
else
  max = b;
\end{minted}
\item Using ternary operator

\begin{minted}[]{C}
max = (a>b) ? a : b;
\end{minted}
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Loops}
\label{sec-1-14}

\begin{itemize}
\item Loops are required when we want to do certain repetetive tasks
\item E.g. Printing the squares of first five numbers without loop would require us to write 5 statements

\begin{minted}[]{C}
main()
{
  printf("%d\n", 1*1);
  printf("%d\n", 2*2);
  printf("%d\n", 3*3);
  printf("%d\n", 4*4);
  printf("%d\n", 5*5);
}
\end{minted}
\item There are different kinds of loops available in C to print that in fewer lines (which is shown after the description of the syntax)
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Loops: while}
\label{sec-1-15}


\begin{minted}[]{C}
while (expression) { 
  statements
}
\end{minted}
\begin{itemize}
\item Using if and goto:

\begin{minted}[]{C}
loop1:
if (expression) {
  statements
  goto loop1;
}
\end{minted}
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Loops: do--while}
\label{sec-1-16}

\begin{itemize}
\item The do-while loop is written as:

\begin{minted}[]{C}
do {
statements
} while (expression);
\end{minted}
\item Note the semicolon after while. Missing that will cause a syntax error
\item Equivalently, using if and goto:

\begin{minted}[]{C}
loop1:
  statements
if (expression)
  goto loop1;
\end{minted}
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Loops: for}
\label{sec-1-17}

\begin{itemize}
\item for loop is written as:

\begin{minted}[]{C}
for (expr1 ; expr2 ; expr3) {
  statements
}
\end{minted}
\item Can be written as an equivalent while loop

\begin{minted}[]{C}
expr1;
while (expr2) {
  statements
  expr3
}
\end{minted}
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{Loops (example) -- Squares of numbers}
\label{sec-1-18}

\begin{itemize}
\item Continuing from the example, printing the squares can be done as follows (do-while)

\begin{minted}[]{C}
int i = 1;
do {
  printf("%d\n", i*i);
  i++;
} while(i<6);
\end{minted}
\item (while)

\begin{minted}[]{C}
int i = 1;
while(i<6) {
  printf("%d\n", i*i);
  i++;
}
\end{minted}
\item (for)

\begin{minted}[]{C}
int i;
for (i=1; i<6; i++) 
  printf("%d\n", i*i);
\end{minted}
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{break and continue}
\label{sec-1-19}

\begin{itemize}
\item \verb~break~ gets the control out of the current loop or switch block
\item \verb~continue~ gets the control directly to the testing of the condition, and begins the next iteration if condition is satisfied
\item E.g. Compute the sum of numbers only if positive numbers are entered

\begin{minted}[]{C}
int a, sum = 0;
while (1) {
  scanf("%d", &a);
  if (a<0)
    break;
  sum += a;
}
\end{minted}
\item Hence, if \verb~1 7 8 3 -4~ are entered, it calculates the sum of first 4 numbers and exits the loop
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{break and continue}
\label{sec-1-20}

\begin{itemize}
\item E.g. Print the first five odd numbers

\begin{minted}[]{C}
int a=0;
while (a<10) {
  a++;
  if (a%2 == 0)
    continue;
  printf("%d\n", a);
}
\end{minted}
\item In the loop body, whenever \verb~a~ becomes even, \verb~continue~ statement is executed, which takes the flow of execution to check the condition \verb~a<10~ and then continues execution depending on the condition result
\end{itemize}
\end{frame}
\begin{frame}[fragile]\frametitle{goto and labels}
\label{sec-1-21}

\begin{itemize}
\item When there is a goto and a label, the statement next to the label gets executed.
\item Usually, it's not preferred since it's difficult to read and maintain such code
\item Used mainly to exit out of deeply nested loops
\item E.g.

\begin{minted}[]{C}
for ( ... )
  for ( ... )
    for ( ... )
      if (solution_found)
        goto found;
found: 
  /* print the solution */
\end{minted}
\item \verb~break~ can terminate only one loop, \verb~goto~ helps to terminate all the outer loops as well
\end{itemize}
\end{frame}

\end{document}
